<!DOCTYPE html>
<html class="no-js">
  <head>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Lambdas and Overloads and Type Traits, Oh My!</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- theme meta -->
<meta name="theme-name" content="airspace-jekyll" />

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

<!-- CSS -->
<link rel="stylesheet" href="/css/owl.carousel.css" />
<link rel="stylesheet" href="/css/bootstrap.min.css" />
<link rel="stylesheet" href="/css/font-awesome.min.css" />
<link rel="stylesheet" href="/css/airspace.css" />
<link rel="stylesheet" href="/css/style.css" />
<link rel="stylesheet" href="/css/ionicons.min.css" />
<link rel="stylesheet" href="/css/animate.css" />
<link rel="stylesheet" href="/css/responsive.css" />
<link rel="stylesheet" href="/css/syntax.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">

<!-- Js -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')</script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/owl.carousel.min.js"></script>
<script src="/js/plugins.js"></script>
<script src="/js/min/waypoints.min.js"></script>
<script src="/js/jquery.counterup.js"></script>
<script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

<!-- scale size of the font -->
MathJax.Hub.Config({
"HTML-CSS": { scale: 90}
});

<!-- Some markdown fixes from http://cwoebker.com/posts/latex-math-magic -->
MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
});
MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

</script>


<script src="/js/main.js"></script>

<!--
/*
 * Airspace
 * Ported to Jekyll by Andrew Lee
 * https://github.com/ndrewtl/airspace-jekyll
 * Designed and Developed by ThemeFisher
 * https://themefisher.com/
 *
 */
-->


  </head>
  <body>


    <!-- Header Start -->
<header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <!-- header Nav Start -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <!-- Brand and toggle get grouped for better mobile display -->
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <!-- <a class="navbar-brand" href="index.html">
                 <img src="/img/logo.png" alt="Logo">
                 </a> -->

          <ul class="nav navbar-icons">
          <!-- Some hack to get the site title in the header -->
          <a href="/"><font size="6">Nils Deppe</font></a>&nbsp;&nbsp;&nbsp;&nbsp;
          
          <a href="/assets/pdfs/cv.pdf" target="_blank" title="CV"><i class="ai ai-cv ai-2x"></i></a>
          
          
          <a href="https://arxiv.org/search/?query=Deppe%2C+Nils&searchtype=author&abstracts=show&order=-announced_date_first&size=200" target="_blank" title="arXiv"><i class="ai ai-arxiv ai-2x"></i></a>
          
          
          <a href="https://github.com/nilsdeppe" target="_blank" title="GitHub"><i class="fab fa-github fa-2x"></i></a>
          
          <!-- 
               <a href="https://bitbucket.com/ndeppe" target="_blank" title="BitBucket"><i class="fab fa-bitbucket fa-2x"></i></a>
                -->
          
          <a href="https://www.linkedin.com/in/nilsdeppe" target="_blank" title="LinkedIn"><i class="fab fa-linkedin fa-2x"></i></a>
          
          </ul>
          </div>
          <!-- Collect the nav links, forms, and other content for toggling -->
          <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
              <ul class="nav navbar-nav navbar-right">
                  <li><a href="/">Home</a></li>
                  <li><a href="/blog">Blog</a></li>
                  <!-- <li><a href="/work">Research</a></li> -->
              </ul>
          </div><!-- /.navbar-collapse -->
        </div><!-- /.container-fluid -->
      </nav>
    </div>
  </div>
</div>
</header><!-- header close -->



    <div class="post">
  <!-- Wrapper Start -->
  <section id="intro" style="border: 1px dotted #ddd;">
    <div class="container">
      <div class="row">
        <div>
          <div class="block">
            <h1>Lambdas and Overloads and Type Traits, Oh My!</h1>
            <div class="post-info-wrapper">
              <p class="italic">By <span class="bold"></span> on <span class="bold">September 10, 2017</span></p>
            </div>
            <hr />
            <p><p>In this post I will discuss overloading generic lambdas in C++14, using SFINAE
with lambdas, using tagged dispatch for “pseudo-SFINAE”, and finally using
overloading and SFINAE to create local type traits inside functions. All of
these are useful when writing generic code. Overloading generic lambdas,
for example, proves to be extremely useful when implementing a stream operator
for <code class="language-plaintext highlighter-rouge">std::tuple</code>. I’m sure you can think of reasons why a type trait is useful
only in the current scope and writing a <code class="language-plaintext highlighter-rouge">struct</code> elsewhere for it is overkill
(e.g. checking for the existence of a member function of a template parameter).</p>

<h3 id="overloaded-lambdas">Overloaded Lambdas</h3>

<p>C++ provides us with the first ingredient needed for overloaded lambdas: the
lambdas. The second ingredient that we need is a method of overloading the call
operator of a lambda. Unfortunately, there is no language support for this
so we must implement this ourselves using existing language facilities. If we
have a class <code class="language-plaintext highlighter-rouge">overloader</code> that derives
off some other class, <code class="language-plaintext highlighter-rouge">B</code>, then we can bring <code class="language-plaintext highlighter-rouge">B</code>’s call operator into scope
with <code class="language-plaintext highlighter-rouge">using B::operator();</code>. Let me be concrete about what I mean:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">overloader</span> <span class="o">:</span> <span class="n">F</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">F</span><span class="o">::</span><span class="k">operator</span><span class="p">();</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This gets us what we want for one non-function invokable (a lambda or function
object). However, we want to be able to overload the call operator N times,
so we need to use a variadic struct template—C++17 makes this
problem quite <a href="/posts/variadic-using">easy</a>. In C++11/14
we can use recursion with fast-tracking
to implement <code class="language-plaintext highlighter-rouge">overloader</code>, and given that there will typically only be a
handful of overloads the recursive approach is fine. Let’s see what this
looks like:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Fs</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">overloader</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F2</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Fs</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">overloader</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Fs</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">overloader</span><span class="o">&lt;</span><span class="n">Fs</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="n">overloader</span><span class="p">(</span><span class="n">F1</span> <span class="n">f1</span><span class="p">,</span> <span class="n">F2</span> <span class="n">f2</span><span class="p">,</span> <span class="n">Fs</span><span class="p">...</span> <span class="n">fs</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">F1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f1</span><span class="p">)),</span>
        <span class="n">F2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f2</span><span class="p">)),</span>
        <span class="n">overloader</span><span class="o">&lt;</span><span class="n">Fs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fs</span><span class="p">)...)</span> <span class="p">{}</span>

  <span class="k">using</span> <span class="n">F1</span><span class="o">::</span><span class="k">operator</span><span class="p">();</span>
  <span class="k">using</span> <span class="n">F2</span><span class="o">::</span><span class="k">operator</span><span class="p">();</span>
  <span class="k">using</span> <span class="n">overloader</span><span class="o">&lt;</span><span class="n">Fs</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">overloader</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">F</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">explicit</span> <span class="n">overloader</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">F</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{}</span>

  <span class="k">using</span> <span class="n">F</span><span class="o">::</span><span class="k">operator</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">overloader_details</span> <span class="p">{</span>
<span class="k">struct</span> <span class="nc">no_such_type</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// namespace overloader_details</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">overloader</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">overloader_details</span><span class="o">::</span><span class="n">no_such_type</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span>  <span class="cm">/*unused*/</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>More fast-tracks can easily be added, e.g. for four and eight invokables.</p>

<p>Alright, let’s walk through what is happening in the above code. First
we declare a variadic struct template, <code class="language-plaintext highlighter-rouge">overloader</code> on line 1. Next, on line 4
we provide a specialization that matches for two or more <code class="language-plaintext highlighter-rouge">F</code>s and derives off
<code class="language-plaintext highlighter-rouge">F1</code>, <code class="language-plaintext highlighter-rouge">F2</code>, and <code class="language-plaintext highlighter-rouge">overloader&lt;Fs...&gt;</code>. This is the simplest fast-track we can have:
it peels off two template parameters instead of one. The constructor receives
the invokables and moves them into the base classes. Finally, we bring the
call operators from <code class="language-plaintext highlighter-rouge">F1</code>, <code class="language-plaintext highlighter-rouge">F2</code> and <code class="language-plaintext highlighter-rouge">overloader&lt;Fs...&gt;</code> into scope by using
three using-declarations. Because we recurse through the parameter pack
<code class="language-plaintext highlighter-rouge">Fs...</code>, by bringing the call operators of <code class="language-plaintext highlighter-rouge">overloader&lt;Fs...&gt;</code> into scope
we also bring all of the call operators of <code class="language-plaintext highlighter-rouge">Fs...</code> into scope.</p>

<p>The second specialization on line 16 is for when there is only a single
invokable. The code is straightforward compared with the fast-track case.
The sentinel specialization on line 27 is different: we need to provide a call
operator so that <code class="language-plaintext highlighter-rouge">using overloader&lt;&gt;::operator()</code> is a valid expression.
However, this call operator overload should never be called and the best
way to ensure that is to have a pointer to an undefined (but declared) type.
If someone tries to create the type <code class="language-plaintext highlighter-rouge">overloader_detail::no_such_type</code> they
will be greeted with a compiler error.</p>

<p>I claim that the above will do exactly what we need: allow us to overload
the call operator of (generic) lambdas. Let’s make life a little easier and
define the utility function <code class="language-plaintext highlighter-rouge">make_overloader</code>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Fs</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">overloader</span><span class="o">&lt;</span><span class="n">Fs</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">make_overloader</span><span class="p">(</span><span class="n">Fs</span><span class="p">...</span> <span class="n">fs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">overloader</span><span class="o">&lt;</span><span class="n">Fs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fs</span><span class="p">)...};</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The point of this utility function is to do the template argument deduction
for us. That is, it deduces the template parameters to <code class="language-plaintext highlighter-rouge">overloader</code>, the
<code class="language-plaintext highlighter-rouge">Fs...</code>, allowing us to simply pass them to the function. This is
especially useful for lambdas whose types are not so straightforward
to figure out. Okay, so now let’s see this in action!</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">const</span> <span class="k">auto</span> <span class="n">lambdas</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="p">},</span>
    <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"string: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="p">});</span>
<span class="n">lambdas</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">lambdas</span><span class="p">(</span><span class="s">"this is a string"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This will print out</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">int: 1
string: this is a string</code></pre></figure>

<h3 id="sfinae-with-overloaded-lambdas">SFINAE With Overloaded Lambdas</h3>

<p>When writing generic code we sometimes want/need to
use SFINAE with a lambda. One example is when writing a stream operator for
<code class="language-plaintext highlighter-rouge">std::tuple</code> where it is necessary to support types that do not have a stream
operator defined. Let’s use SFINAE to select an overload depending on whether a
class has a member <code class="language-plaintext highlighter-rouge">func(int)</code>, for which we can easily write a type trait:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">void_t</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="o">=</span> <span class="n">void_t</span><span class="o">&lt;</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">has_func</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">has_func</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span>
                <span class="n">void_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()))</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
    
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">has_func_v</span> <span class="o">=</span> <span class="n">has_func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I’m assuming you are familiar with writing type traits like this, but if not
then I explain a litte bit of what’s happening with the <code class="language-plaintext highlighter-rouge">decltype()</code> call on line
8 in the section
<a href="#from-overloaded-lambdas-to-type-traits">“From Overloaded Lambdas to Type Traits”</a>
below. To use the type trait for SFINAE of an overloaded lambda we use the
trailing return type syntax as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">check_for_func_member</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">my_lambdas</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">has_func_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Has func(int) member using SFINAE</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">not</span> <span class="n">has_func_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Has no func(int) member using SFINAE</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="n">my_lambdas</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The return type is always <code class="language-plaintext highlighter-rouge">void</code> but which function is called depends on whether
the first or second overload has a substitution failure in the return type.
The resulting behavior is the same as using SFINAE with any regular function.</p>

<p>There is another clever way to have what I call “pseudo-SFINAE” with lambdas.
In this case we write:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">check_for_func_member_overload</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">my_lambdas</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="cm">/*meta*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Has func(int) member using pseudo-SFINAE</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="cm">/*meta*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Has no func(int) member using pseudo-SFINAE</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="n">my_lambdas</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">has_func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">{});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We select which overload we call based on what type
<code class="language-plaintext highlighter-rouge">typename has_func&lt;T&gt;::type</code> is. If it is <code class="language-plaintext highlighter-rouge">true_type</code> we select the first,
and if it is <code class="language-plaintext highlighter-rouge">false_type</code> we select the second. This is effectively tagged
dispatch–using metaprogramming to select which function to resolve to.
This approach has the major advantage that it is, in my opinion, much easier to
understand than the SFINAE case.</p>

<h3 id="understanding-the-overloaded-lambdas">Understanding The Overloaded Lambdas</h3>

<p>We are almost ready to get to the fun stuff—metaprogramming. Before that we
need to understand a little bit more about generic lambdas and overloading.
One thing you may not be aware of is that you can use the trailing return type
syntax to specify the return type of a lambda. What I mean is you can write
<code class="language-plaintext highlighter-rouge">[]() -&gt; double { return 1; }</code> and the return type will be <code class="language-plaintext highlighter-rouge">double</code>, not <code class="language-plaintext highlighter-rouge">int</code>.
We will now (ab)use this to write local type traits. First let’s write
a trait that checks for the existence of a member function <code class="language-plaintext highlighter-rouge">func(int)</code>.
Here is the implementation of the type trait:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">has_func</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
    <span class="p">[](</span><span class="k">auto</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{})</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span> <span class="p">},</span>
    <span class="p">[](</span><span class="k">auto</span><span class="p">...)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You are probably wondering what is happening here. First, we are
creating an <code class="language-plaintext highlighter-rouge">overloader</code> of two lambdas. Let’s talk about the lambda
on line 5 first. The lambda</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="p">[](</span><span class="k">auto</span><span class="p">...)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>translates to</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">LAMBDA_SECOND</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Ts</span><span class="p">...)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Similarly, the lambda on lines 2-4,</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="p">[](</span><span class="k">auto</span> <span class="n">t</span><span class="p">,</span>
   <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">((</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{})</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>translates to</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">LAMBDA_FIRST</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
      <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">((</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{})</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Thus, the resulting overloaded lambda is</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">LAMBDA_OVERLOADER</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
      <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">((</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{})</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Ts</span><span class="p">...)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Hopefully it is now clear how to think about the overloaded lambdas.</p>

<p>I’ll quickly point out that the <code class="language-plaintext highlighter-rouge">(void)</code> on line 3 of the first code block
in this section is necessary to avoid code injection from overloaded
comma operators. That is, if someone were to define
<code class="language-plaintext highlighter-rouge">void operator,(int, std::true_type) {}</code> then the expression passed to the
<code class="language-plaintext highlighter-rouge">decltype()</code> operator on line 2 and 3 of the first block in this section
will be ill-formed.</p>

<h3 id="from-overloaded-lambdas-to-type-traits">From Overloaded Lambdas to Type Traits</h3>

<p>Now that we have the required code, let’s see what happens when we use the type
trait <code class="language-plaintext highlighter-rouge">has_func</code>. The simplest thing we can do is:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">my_type1</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">my_type2</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Trait</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Type</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">local_trait_v</span> <span class="o">=</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Trait</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">()...,</span> <span class="mi">0</span><span class="p">))</span><span class="o">::</span><span class="n">value</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">local_type_trait_example1</span><span class="p">(</span><span class="n">T</span> <span class="cm">/*t*/</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">has_func_impl</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span>
          <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">().</span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()),</span>
          <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{})</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span> <span class="p">},</span>
      <span class="p">[](</span><span class="k">auto</span><span class="p">...)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">});</span>
  <span class="k">using</span> <span class="n">has_func_member</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">has_func_impl</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Has func(int) member function: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span>
            <span class="o">&lt;&lt;</span> <span class="n">local_trait_v</span><span class="o">&lt;</span><span class="n">has_func_member</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">local_type_trait_example1</span><span class="p">(</span><span class="n">my_type1</span><span class="p">{});</span>
  <span class="n">local_type_trait_example1</span><span class="p">(</span><span class="n">my_type2</span><span class="p">{});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>which prints out</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Has func(int) member function: true
Has func(int) member function: false</code></pre></figure>

<p>First I’ll explain <code class="language-plaintext highlighter-rouge">local_trait_v</code> (line 7), which is simply a helper
<code class="language-plaintext highlighter-rouge">constexpr</code> variable used
to reduce the amount of typing necessary to evaluate local type traits. It
takes the trait to evaluate as its first template parameter and the types to
pass to the trait as the parameter pack. Because lambdas cannot
appear in an unevaluated context we must declare the variable <code class="language-plaintext highlighter-rouge">has_func_impl</code>
rather than having the <code class="language-plaintext highlighter-rouge">make_overloader</code> call be inside the <code class="language-plaintext highlighter-rouge">decltype()</code> call
on line 17.</p>

<p>You should now be able to follow the call to <code class="language-plaintext highlighter-rouge">local_trait_v</code> on line 20 back to
overload resolution of the call operator. So how does the compiler actually
decide which return type to deduce from the call operator? Well, if the
expression to <code class="language-plaintext highlighter-rouge">decltype()</code> in the trailing return type on line 13 is evaluable,
i.e. <code class="language-plaintext highlighter-rouge">decltype(t)</code> has a member function <code class="language-plaintext highlighter-rouge">func(int)</code>, then the first overload is
preferred if and only if the second argument to the call operator is an <code class="language-plaintext highlighter-rouge">int</code>.
This is why <code class="language-plaintext highlighter-rouge">local_trait_v</code> calls <code class="language-plaintext highlighter-rouge">(type, 0)</code>: the <code class="language-plaintext highlighter-rouge">0</code> matches <code class="language-plaintext highlighter-rouge">int</code>,
which is a better match than <code class="language-plaintext highlighter-rouge">auto...</code> in the call operator on line 16. However,
if the call were <code class="language-plaintext highlighter-rouge">(type, 0L)</code>, the <code class="language-plaintext highlighter-rouge">0L</code> would match <code class="language-plaintext highlighter-rouge">auto...</code> because then there
is no implicit cast to from <code class="language-plaintext highlighter-rouge">long</code> to <code class="language-plaintext highlighter-rouge">int</code>. If you have written a lot of type
traits then this trick will be familiar, though frequently C-style variadic
functions are used, which I’m intentionally avoiding.</p>

<h3 id="another-local-type-trait-example">Another Local Type Trait Example</h3>

<p>Another interesting class of type traits are the <code class="language-plaintext highlighter-rouge">is_</code>, for example
<code class="language-plaintext highlighter-rouge">is_std_map</code>. Let’s write that one and use it! Here is the implementation:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="nf">local_type_trait_example2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">is_std_map</span> <span class="o">=</span> <span class="n">make_overloader</span><span class="p">(</span>
      <span class="p">[](</span><span class="k">auto</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span>
          <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">typename</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">::</span><span class="n">key_type</span><span class="p">,</span>
                                <span class="k">typename</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">::</span><span class="n">mapped_type</span><span class="p">,</span>
                                <span class="k">typename</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">::</span><span class="n">key_compare</span><span class="p">,</span>
                                <span class="k">typename</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">::</span><span class="n">allocator_type</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span> <span class="p">},</span>
      <span class="p">[](</span><span class="k">auto</span><span class="p">...)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span> <span class="p">});</span>

  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is a map: "</span> <span class="o">&lt;&lt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">is_std_map</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is a map: "</span> <span class="o">&lt;&lt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">is_std_map</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is a map: "</span> <span class="o">&lt;&lt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">is_std_map</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The trait checks that the member aliases <code class="language-plaintext highlighter-rouge">key_type</code>, <code class="language-plaintext highlighter-rouge">mapped_type</code>,
<code class="language-plaintext highlighter-rouge">key_compare</code> and <code class="language-plaintext highlighter-rouge">allocator_type</code> exist, and then that a <code class="language-plaintext highlighter-rouge">std::map</code>
with the same template parameters is the same type as what was passed in to <code class="language-plaintext highlighter-rouge">t</code>.
This is definitely not the most common way of implementing the type trait if
one were using a <code class="language-plaintext highlighter-rouge">struct</code>, but the result is perfectly adequate and works
within the restrictions of overloaded lambdas.</p>

<h3 id="summary">Summary</h3>

<p>In this post we explored how to overload the call operator of a (generic)
lambda, use SFINAE and tagged dispatch for “pseudo-SFINAE” in overloaded
lambdas, and (ab)use these to implement type traits locally within
functions. The result is several different ways of performing fairly complex
metaprogramming tasks within a narrower scope than was previously possible.
This helps to simplify the amount of code that needs to be analyzed when
reasoning about what a function does. The
biggest gain from these methods is for library implementers who write a lot
of generic code. I have shared a complete, working example of the code
snippets shown here on my
<a href="https://github.com/nilsdeppe/template-metaprogramming-tutorials">GitHub</a>
in the file <code class="language-plaintext highlighter-rouge">local-type-traits.cpp</code>.</p>

<p>I hope you enjoyed the post and thanks for reading!</p>
</p>
          </div>
        </div><!-- .col-md-7 close -->
      </div>
    </div>
  </section>
</div>
<p class="center-text" style="padding: 30px;">
  <a href="/blog">Back to blog</a>
</p>


<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'nilsdeppe'; // required: replace example with your forum shortname
        // var disqus_developer = 1; // Comment out when the site is live
        var disqus_identifier = "/posts/local-type-traits";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>












    <!-- footer Start -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="footer-manu">
          <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/blog">Blog</a></li>
            <li><a href="/contact">Contact</a></li>
            
            <li><a href="/assets/pdfs/cv.pdf" target="_blank" title="CV"><i class="ai ai-cv ai-1x"></i></a></li>
            
            
            <li><a href="https://orcid.org/0000-0003-4557-4115" target="_blank" title="ORCID"><i class="ai ai-orcid ai-1x"></i></a></li>
            
            
            <li><a href="https://arxiv.org/search/?query=Deppe%2C+Nils&searchtype=author&abstracts=show&order=-announced_date_first&size=200" target="_blank" title="arXiv"><i class="ai ai-arxiv ai-1x"></i></a></li>
            
            
            <li><a href="https://github.com/nilsdeppe" target="_blank" title="GitHub"><i class="fab fa-github fa-1x"></i></a></li>
            
            
            <li><a href="https://www.linkedin.com/in/nilsdeppe" target="_blank" title="LinkedIn"><i class="fab fa-linkedin fa-1x"></i></a></li>
            
          </ul>
        </div>
        <p>Copyright &copy; Design &amp; Developed by <a href="http://www.themefisher.com">Themefisher</a>. All rights reserved.</p>
      </div>
    </div>
  </div>
</footer>


    </body>
</html>
